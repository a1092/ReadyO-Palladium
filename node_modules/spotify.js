var util = require('util');
var logger = require('logger');
var unirest = require('unirest');
var EventEmitter = require('events').EventEmitter;



var Spotify = function (desktop, general) {

	EventEmitter.call(this);

	this.protocol = desktop.protocol;
	this.host = desktop.host;
	this.port = desktop.port;
	this.proxy = general.proxy;

	self = this;

	this.oauth = null;
	this.csrf = null;

	this.status = {track:"", artist:"", album:"", state: null};

	self.time2reconnect = 0;
	
	this.on('com/spotify/remote/play', function(spotifyUri) {

		self.request("/remote/play.json", {'csrf': self.csrf, 'oauth': self.oauth, 'uri': spotifyUri, 'context': spotifyUri}, function(data) {
			//console.log(data);
		});
	});

	this.on('com/spotify/remote/pause', function(status) { // status = true | false
		
		self.request("/remote/pause.json", {'csrf': self.csrf, 'oauth': self.oauth, 'pause': status}, function(data) {
			//console.log(data);
		});
	});

	this.on('com/spotify/remote/next', function(data) {
		logger.info("Next is not available yet.", { app: "spotify" });
	});

	this.on('com/spotify/remote/previous', function(data) {
		logger.info("Previous is not available yet.", { app: "spotify" });
	});

	this.on('com/spotify/player/ready', function() {
		self.player();
	});


}

util.inherits(Spotify, EventEmitter);


Spotify.prototype.player = function() {

	self = this;


	self.request("/remote/status.json", {'csrf': self.csrf, 'oauth': self.oauth, 'returnafter': '59', 'returnon': 'login,logout,play,pause,error,ap'}, function(data) {
        	
    	if(data.playing) {
        	if(self.status.state != data.playing || self.status.track != data.track.track_resource.uri) {

        		self.emit("com/spotify/player/status", {
        			playing: true,
        			media: { 
						track: {
							name: data.track.track_resource.name,
							spotify: data.track.track_resource.uri
						},
						artist: {
							name: data.track.artist_resource.name,
							spotify: data.track.artist_resource.uri
						},
						album: {
							name: data.track.album_resource.name,
							spotify: data.track.album_resource.uri
						}
					}
        		});

				self.status.track = data.track.track_resource.uri;
				self.status.artist = data.track.artist_resource.uri;
				self.status.album = data.track.album_resource.uri;

				logger.info("New song is playing : "+data.track.track_resource.name+" - "+data.track.artist_resource.name+" - "+data.track.album_resource.name, { app: "spotify" });
			}
		
		} else if(self.status.state != data.playing) {
        	self.emit("com/spotify/player/status", {
    			playing: false,
    			media: {
				}
    		});
		}

		self.status.state = data.playing;

    	self.player();
    });
    
}



Spotify.prototype.connect = function connect() {
	
	self = this;

	getOAuthToken();

	function getOAuthToken() {
		unirest
			.get('https://open.spotify.com/token')
			.headers({'content-type': 'application/json'})
			.proxy(self.proxy)
			.end(function (response) {
				self.oauth = response.body.t;
				logger.info("The token OAUTH was retrieved : "+self.oauth, { app: "spotify" });
				getCsrfToken();
			})
		;
	}


	function getCsrfToken() {

		self.request("/simplecsrf/token.json", {}, function(data) {

			self.csrf = data.token;

			logger.info("The token CSRF was retrieved : "+self.csrf, { app: "spotify" });
			
			self.time2reconnect = 0;

			self.emit("com/spotify/player/ready");
		});
	}
}

Spotify.prototype.request = function request(uri, query, callback) {

	self = this;

	unirest
		.get(self.protocol+'://'+self.host+':'+self.port+uri)
		.headers({ 'Origin': 'https://open.spotify.com','content-type': 'application/json' })
		.query(query)
        .end(function(response) {

        	if(response.error) {
        		logger.error("Spotify has responded a "+response.error+" error.", { app: "spotify" })


        		if(self.time2reconnect < 120)
					self.time2reconnect += 10;

				logger.info("Reconnection to Spotify in "+self.time2reconnect+" sec.", { app: "spotify" });
				
				setTimeout(function() {
					self.connect();
				}, self.time2reconnect*1000);

        	} else {
        		callback(response.body);
        	}
        })
    ;
}

function extend(target) {
    var sources = [].slice.call(arguments, 1);
    sources.forEach(function (source) {
        for (var prop in source) {
            target[prop] = source[prop];
        }
    });
    return target;
}


module.exports = Spotify;
